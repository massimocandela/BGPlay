"""OpenBMP MRT

  Copyright (c) 2013-2016 Cisco Systems, Inc. and others.  All rights reserved.
  This program and the accompanying materials are made available under the
  terms of the Eclipse Public License v1.0 which accompanies this distribution,
  and is available at http://www.eclipse.org/legal/epl-v10.html

  .. moduleauthor:: Tim Evens <tievens@cisco.com>
"""
import socket

from struct import pack, unpack

#: Attribute Flags
#:  bit 0 = optional
#:  bit 1 = transitive
#:  bit 2 = partial
#:  bit 3 = extended length (2-octet)
#:  bits 4 - 7 are zero
ATTR_FLAGS_OPT = 0x80
ATTR_FLAGS_TRANS = 0x40
ATTR_FLAGS_PARTIAL = 0x20
ATTR_FLAGS_EXLEN = 0x10

#: Attribute Types
ATTR_TYPE_ORIGIN = pack('!BB', ATTR_FLAGS_TRANS, 1)
ATTR_TYPE_AS_PATH = pack('!BB', ATTR_FLAGS_TRANS | ATTR_FLAGS_EXLEN, 2)
ATTR_TYPE_NEXTHOP = pack('!BB', ATTR_FLAGS_TRANS, 3)
ATTR_TYPE_MED = pack('!BB', ATTR_FLAGS_OPT | ATTR_FLAGS_TRANS, 4)
ATTR_TYPE_LOCAL_PREF = pack('!BB', ATTR_FLAGS_TRANS, 5)
ATTR_TYPE_ATOMIC_AGG = pack('!BB', ATTR_FLAGS_TRANS, 6)
ATTR_TYPE_AGGREGATOR = pack('!BB', ATTR_FLAGS_OPT | ATTR_FLAGS_TRANS, 7)
ATTR_TYPE_COMMUNITIES = pack('!BB',  ATTR_FLAGS_OPT | ATTR_FLAGS_TRANS | ATTR_FLAGS_EXLEN, 8)
ATTR_TYPE_ORIGINATOR_ID = pack('!BB',  ATTR_FLAGS_OPT | ATTR_FLAGS_TRANS, 9)
ATTR_TYPE_CLUSTER_LIST = pack('!BB',  ATTR_FLAGS_OPT | ATTR_FLAGS_TRANS, 10)
ATTR_TYPE_MP_REACH = pack('!BB',  ATTR_FLAGS_OPT, 14)

#: Origin Code
ORIGIN_CODE_IGP = 0
ORIGIN_CODE_EGP = 1
ORIGIN_CODE_INCOMPLETE = 2

#: AS_PATH segment types
AS_PATH_SEG_AS_SET = 1
AS_PATH_SEG_AS_SEQ = 2


def encode_attr_origin(origin):
    """ Encode string origin into a BGP ORIGIN attribute TLV

        :param origin:      String value for the origin

        :return: BGP attribute TLV ready to be written
    """
    origin_code = ORIGIN_CODE_IGP

    if 'egp' in origin:
        origin_code = ORIGIN_CODE_EGP
    elif 'incomplete' in origin:
        origin_code = ORIGIN_CODE_INCOMPLETE

    return ATTR_TYPE_ORIGIN + pack('!B', 1) + pack('!B', origin_code)


def encode_attr_as_path(as_path):
    """ Encode string AS_PATH into a BGP AS_PATH attribute TLV

        ..note: Always uses 4 octet ASN encoding

        :param as_path:      String delimited list of ASNs (can include AS SET { })

        :return: BGP attribute TLV ready to be written
    """
    as_path_segments = ""

    as_seg_list = []
    enc_segment = pack("B", AS_PATH_SEG_AS_SEQ)

    paths = as_path.strip().split(" ")
    for path in paths:

        if len(path):
            # Start of AS-SET
            if path[0] == '{':

                # If not the ASN first in segment, encode segment and start a new AS-SET segment
                if len(as_seg_list) > 0:
                    # encode current segment
                    enc_segment += pack("B", len(as_seg_list))
                    for asn in as_seg_list:
                        enc_segment += pack("!I", int(asn))

                    as_path_segments += enc_segment

                # new segment
                enc_segment = pack("B", AS_PATH_SEG_AS_SET)
                as_seg_list = []

                # Remove AS-SET character
                if len(path) > 1:
                    path = path[1:]
                else:
                    # If it is the only character, skip to next
                    continue

            # End of AS-SET, encode segment and start a new one for next pass
            elif path[0] == '}':
                # encode current segment
                enc_segment += pack("B", len(as_seg_list))
                for asn in as_seg_list:
                    enc_segment += pack("!I", int(asn))

                as_path_segments += enc_segment

                # new AS-SEQ segment
                enc_segment = pack("B", AS_PATH_SEG_AS_SEQ)
                as_seg_list = []
                continue

            # Append AS to segment
            as_seg_list.append(path)

    # encode final segment
    if len(as_seg_list) > 0:
        enc_segment += pack("B", len(as_seg_list))
        for asn in as_seg_list:
            enc_segment += pack("!I", int(asn))

        as_path_segments += enc_segment

    # encode the attribute tlv for all as path segments
    return ATTR_TYPE_AS_PATH + pack("!H", len(as_path_segments)) + as_path_segments


def encode_attr_nexthop(nexthop):
    """ Encode string nexthop into a BGP NEXTHOP attribute TLV

        This encodes RFC4271 nexthop attribute, not RFC4760/next-hop

        :param nexthop:      String value for the next-hop

        :return: BGP attribute TLV ready to be written
    """
    return ATTR_TYPE_NEXTHOP + pack('!B', 4) + socket.inet_pton(socket.AF_INET, nexthop)


def encode_attr_mp_nexthop(nexthop):
    """ Encode string nexthop into a BGP MP_REACH attribute TLV

        A modified MP_REACH attribute that includes only the next hop info (per MRT RFC6396)
        This includes only the next hop address lenght (1 octet) and the next-hop

        :param nexthop:      String value for the next-hop

        :return: BGP attribute TLV ready to be written
    """
    # Set afi and length based on nexthop address
    if ':' in nexthop:
        nh_len = 16
        afi = socket.AF_INET6
    else:
        nh_len = 4
        afi = socket.AF_INET

    return ATTR_TYPE_MP_REACH + pack('!BB', nh_len + 1, nh_len) + socket.inet_pton(afi, nexthop)


def encode_attr_med(value):
    """ Encode string med value into a BGP MED attribute TLV

        :param value:      String value

        :return: BGP attribute TLV ready to be written
    """
    return ATTR_TYPE_MED + pack('!BI', 4, long(value))


def encode_attr_local_pref(value):
    """ Encode string local pref value into a BGP MED attribute TLV

        :param value:      String value

        :return: BGP attribute TLV ready to be written
    """
    return ATTR_TYPE_LOCAL_PREF + pack('!BI', 4, long(value))


def encode_attr_atomic_agg():
    """ Encode atomic aggregate into a BGP ATOMIC AGGREGATE attribute TLV

        :return: BGP attribute TLV ready to be written
    """
    return ATTR_TYPE_ATOMIC_AGG + pack('!B', 0)


def encode_attr_aggregator(aggregator):
    """ Encode string aggregator <asn ip> value into a BGP MED attribute TLV

        ..note: Always uses 4 octet ASN encoding

        :param aggregator:      String value of "<ASN> <IPv4 Router ID>"

        :return: BGP attribute TLV ready to be written
    """
    try:
        (asn, ip) = aggregator.split(" ")

        return ATTR_TYPE_AGGREGATOR + pack('!BI', 8, long(asn)) + socket.inet_pton(socket.AF_INET, ip)
    except:
        return ""


def encode_attr_communities(communities):
    """ Encode string community list into a BGP COMMUNITY attribute TLV

        :param communities:      String space delimited list of communities in the format of nn:nn

        :return: BGP attribute TLV ready to be written
    """
    encode_comm = ''
    try:
        for comm in communities.split(' '):
            (h, l) = comm.split(':')
            encode_comm += pack("!I", int(h) << 16 | int(l))

        return ATTR_TYPE_COMMUNITIES + pack('!H', len(encode_comm)) + encode_comm
    except:
        return ''


def encode_attr_originator_id(originator):
    """ Encode string originator into a BGP ORIGINATOR_ID attribute TLV

        :param originator:      String value for the originator router/bgp id

        :return: BGP attribute TLV ready to be written
    """
    return ATTR_TYPE_ORIGINATOR_ID + pack('!B', 4) + socket.inet_pton(socket.AF_INET, originator)


def encode_attr_cluster_list(cluster_list):
    """ Encode string cluster_list into a BGP CLUSTER_LIST attribute TLV

        :param cluster_list:      String space delimited list of cluster id's

        :return: BGP attribute TLV ready to be written
    """
    encode_cluster_list = ""

    try:
        for cluster_id in cluster_list.split(' '):
            encode_cluster_list += socket.inet_pton(socket.AF_INET, cluster_id)

        return ATTR_TYPE_CLUSTER_LIST + pack('!B', len(encode_cluster_list)) + encode_cluster_list

    except:
        return ''


def get_asn_encoding(attr_data, len):
    """ Goes through all attribute data to detect the ASN encoding

        Attempts to parse the AS_PATH using 4 octet. If parse fails, it's
        2-octet encoded.  Aggregator can also be used to detect this, but
        that attribute isn't always present.

        :param attr_data:   Attribute data from BGP update message
        :param len:         Length of the attribute data

        :return: 2 for 2-octet, 4 for 4-octet, and 0 if cannot be detected
    """
    asn_len = 0
    attr_read = 0

    while attr_read < len:
        (attr_flags, attr_type) = unpack('!BB', attr_data[attr_read: attr_read + 2])
        attr_read += 2

        if ATTR_FLAGS_EXLEN & attr_flags:
            (attr_len,) = unpack('!H', attr_data[attr_read: attr_read + 2])
            attr_read += 2
        else:
            (attr_len,) = unpack('!B', attr_data[attr_read: attr_read + 1])
            attr_read += 1

        if attr_type == 2:
            if attr_len > 0:
                path_data = attr_data[attr_read: attr_read + attr_len]
                path_read = 0
                while path_read < attr_len:
                    (path_type, path_count) = unpack("!BB", path_data[path_read: path_read + 2])
                    path_read += 2
                    path_read += 4 * path_count

                if path_read > attr_len:
                    asn_len = 2
                else:
                    asn_len = 4
            break

        attr_read += attr_len

    return asn_len


def parse_update_hdr(data, len):
    """ Parse BGP update header from BGP message data

        ..note:: Does not parse attributes or NLRI's

    :param data:    Data for the update, MUST start at the update message data
    :param len:     Length of the update message

    :return: dictionary defined as::
            {
                attr_len:       <attribute length>
                attr_data:      <Data for attributes>
                nlri_len:       <nlri length>
                nlri_data:      <Data for nlri's>
                withdrawn_len:  <withdrawn len>
                withdrawn_data: <Data for withdrawn nlri's>
            }
    """
    update = {}
    ptr = 2

    (withdrawn_len,) = unpack('>H', data[:ptr])
    ptr += withdrawn_len

    if withdrawn_len > 0:
        withdrawn_data = data[2:ptr]
    else:
        withdrawn_data = ""

    (attr_len,) = unpack('>H', data[ptr:ptr + 2])
    ptr += 2

    attr_data = data[ptr: ptr + attr_len]
    ptr += attr_len

    nlri_len = len - ptr

    if nlri_len > 0:
        nlri_data = data[ptr:ptr + nlri_len]
    else:
        nlri_data = ""

    update['withdrawn_len'] = withdrawn_len
    update['withdrawn_data'] = withdrawn_data
    update['attr_len'] = attr_len
    update['attr_data'] = attr_data
    update['nlri_len'] = nlri_len
    update['nlri_data'] = nlri_data

    return update


def parse_bgp_hdr(data):
    """ Parse BGP header

    :param data:      BGP message data, MUST include BGP marker

    :return: dictionary defined as::
            {
                type:       <string; Type of BGP message>,
                type_code:  <int value for type>
                length:     <int; length of bgp message, not including common header>
            }
    """
    hdr = {}

    marker = data[:16]

    if len(marker) != 16:
        return None

    (sz, bgp_type) = unpack('>HB', data[16:19])

    hdr['length'] = sz - 19

    hdr['type_code'] = int(bgp_type)

    if bgp_type == 1:
        hdr['type'] = "OPEN"
    elif bgp_type == 2:
        hdr['type'] = "UPDATE"
    elif bgp_type == 3:
        hdr['type'] = "NOTIFICATION"
    elif bgp_type == 4:
        hdr['type'] = "KEEPALIVE"
    elif bgp_type == 5:
        hdr['type'] = "ROUTE_REFRESH"
    else:
        hdr['type'] = "UNKNOWN=%d" % type

    return hdr
