# -*- coding: utf-8 -*-
# encoding=utf8
"""OpenBMP MRT

  Copyright (c) 2013-2016 Cisco Systems, Inc. and others.  All rights reserved.
  This program and the accompanying materials are made available under the
  terms of the Eclipse Public License v1.0 which accompanies this distribution,
  and is available at http://www.eclipse.org/legal/epl-v10.html

  .. moduleauthor:: Tim Evens <tievens@cisco.com>
"""
import multiprocessing
import socket
import os
import logging
import bgp

from struct import pack
from openbmp.logger import init_mp_logger
from openbmp.RawTimedRotatingFileHandler import RawTimedRotatingFileHandler
from openbmp.bmp import resolveIp


class MrtBgp4MpWriter(multiprocessing.Process):
    """ BMP to MRT BGP4MP writer

        Pops messages from mrt_bgp4mp_queue and writes them to the log file.
        Log file is rotated based on rotation configuration.
    """
    # Dictionary to track Loggers
    #     Key = <concat of collector, router, and peer addr>, Value = logger)
    PEER_LOGGERS = {}

    # Dictionary to track peer asn length
    #     Key = <concat of collector, router, and peer addr>, Value = 2 or 4)
    PEER_ASN_LENGTH = {}

    def __init__(self, cfg, mrt_bgp4mp_queue, log_queue):
        """ Constructor

            :param cfg:               Configuration dictionary
            :param mrt_bgp4mp_queue:  Output for BMP raw message forwarding
            :param log_queue:         Logging queue - sync logging
        """
        multiprocessing.Process.__init__(self)
        self._stop = multiprocessing.Event()

        self._cfg = cfg
        self._bgp4mp_queue = mrt_bgp4mp_queue
        self._log_queue = log_queue
        self.LOG = None

        self._sock = None

    def run(self):
        """ Override """
        self.LOG = init_mp_logger("mrt_bgp4mp_writer", self._log_queue)

        self.LOG.info("Running mrt_bgp4mp_writer")

        try:
            # wait for the mapping config to be loaded
            while not self.stopped():
                if self._cfg and 'logging' in self._cfg:
                    break

            # process queue
            while not self.stopped():

                # pop message from queue - block if no messages avail
                msg = self._bgp4mp_queue.get()

                # Process the BMP message
                self.process_msg(msg)

                #self.LOG.debug("Received bmp message: %s %s %s", msg.COLLECTOR_ADMIN_ID,
                #               msg.ROUTER_IP, msg.ROUTER_NAME)

        except KeyboardInterrupt:
            pass

        self.LOG.info("mrt_bgp4mp_writer stopped")

    def process_msg(self, msg):
        """ Process the queue message

        :param msg:     MrtBgpMpObject class object that was received from the queue

        :return: none
        """
        logger_hash = msg.COLLECTOR_HASH_ID + '_' + msg.ROUTER_IP + '_' + msg.PEER_ADDR;

        # Add logger if it doesn't exist
        if logger_hash not in self.PEER_LOGGERS:
            peer_afi = "IPV6" if ':' in msg.PEER_ADDR else 'IPV4'
            filepath = os.path.join(self._cfg['bgp4mp']['log_dir'],
                                    'COLLECTOR_' + msg.COLLECTOR_HASH_ID,
                                    'ROUTER_' + resolveIp(msg.ROUTER_IP),
                                    'PEER_' + peer_afi + '_' + resolveIp(msg.PEER_ADDR))
            try:
                os.makedirs(filepath)
            except:
                pass

            self.PEER_LOGGERS[logger_hash] = self.init_logger('openbmp.mrt.peer.' + logger_hash,
                                                              os.path.join(filepath, 'updates.mrt'))
            self.PEER_ASN_LENGTH[logger_hash] = 0

        # Write/log BGP4MP message
        self.write_msg(logger_hash, msg)

    def write_msg(self, logger_hash, msg):
        """ Writes the BGP4MP message based on the message passed

        :param logger_hash:     Hash/ID used for logger reference
        :param msg:             MrtBgpMpObject class object that was received from the queue
        """
        isIPv4 = True if '.' in msg.PEER_ADDR else False
        asn_len = 4

        # Get ASN length/encoding
        #   Prefer the ASN encoding from peer up message first
        if msg.PEER_ASN_LENGTH != 0:
            self.PEER_ASN_LENGTH[logger_hash] = msg.PEER_ASN_LENGTH
            asn_len = msg.PEER_ASN_LENGTH

        elif self.PEER_ASN_LENGTH[logger_hash] == 0:
            # auto-detect asn encoding
            update_msg = bgp.parse_update_hdr(msg.BMP_DATA[19:], len(msg.BMP_DATA[19:]))
            asn_len = bgp.get_asn_encoding(update_msg['attr_data'], update_msg['attr_len'])

            self.LOG.info("Peer %s auto detected ASN encoding as %d", logger_hash, asn_len)

            if asn_len == 2 or asn_len == 4:
                self.PEER_ASN_LENGTH[logger_hash] = asn_len

        else:
            asn_len = self.PEER_ASN_LENGTH[logger_hash]

        # extend common header, but not supported by libbgpdump, so it's not used here
        # 0                   1                   2                   3
        # 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |                           Timestamp                           |
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |             Type              |            Subtype            |
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |                             Length                            |
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |                      Microsecond Timestamp                    |
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |                      Message... (variable)
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        #mrt_msg = pack("!IHHII", msg.TIMESTAMP_SEC,
        #               17, 4,       # Type is BGP4MP_ET, SubType is BGP4MP_MESSAGE_AS4
        #               12 + (8 if isIPv4 else 32) + len(msg.BMP_DATA),
        #               msg.TIMESTAMP_USEC)

        # 0                   1                   2                   3
        # 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |                           Timestamp                           |
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |             Type              |            Subtype            |
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |                             Length                            |
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |                      Message... (variable)
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        mrt_msg = pack("!IHHI", msg.TIMESTAMP_SEC,
                       16,       # Type is BGP4MP
                       4 if asn_len == 4 else 1,  # SubType is BGP4MP_MESSAGE_AS4 or BGP4MP_MESSAGE

                       asn_len * 2 + 4 + (8 if isIPv4 else 32) + len(msg.BMP_DATA))

        # BGP4MP_MESSAGE is same as below, but 2 octets for ASN number
        # Build BGP4MP_MESSAGE_AS4 - https://tools.ietf.org/html/rfc6396#section-4.4.3
        #          0                   1                   2                   3
        #  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |                         Peer AS Number                        |
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |                         Local AS Number                       |
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |        Interface Index        |        Address Family         |
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |                      Peer IP Address (variable)               |
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |                      Local IP Address (variable)              |
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        # |                    BGP Message... (variable)
        # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        if asn_len == 4:
            mrt_msg += pack("!II", msg.PEER_ASN, msg.LOCAL_ASN)
        else:
            mrt_msg += pack("!HH", msg.PEER_ASN, msg.LOCAL_ASN)

        mrt_msg += pack("!H", 0)           # Index - currently always zero

        mrt_msg += pack("!H", 1 if isIPv4 else 2)  # Address family for peer addresses

        if isIPv4:
            mrt_msg += socket.inet_pton(socket.AF_INET, msg.PEER_ADDR)
            mrt_msg += socket.inet_pton(socket.AF_INET,
                                        "127.0.0.1" if not msg.LOCAL_ADDR else msg.LOCAL_ADDR)

        else:
            mrt_msg += socket.inet_pton(socket.AF_INET6, msg.PEER_ADDR)
            mrt_msg += socket.inet_pton(socket.AF_INET6,
                                        "::1" if not msg.LOCAL_ADDR else msg.LOCAL_ADDR)

        mrt_msg += msg.BMP_DATA

        self.PEER_LOGGERS[logger_hash].info(mrt_msg)

    def stop(self):
        self._stop.set()

    def stopped(self):
        return self._stop.is_set()

    def init_logger(self, name, filename):
        """ Initialize a new logger instance

        :param name:        name of logger
        :param filename:    Filename for the logger

        :return: logger instance
        """
        logger = logging.getLogger(name)

        for h in logger.handlers:
            logger.removeHandler(h)

        handler = RawTimedRotatingFileHandler(
                            filename=filename,
                            when=self._cfg['bgp4mp']['rotate']['when'],
                            interval=self._cfg['bgp4mp']['rotate']['interval'],
                            backupCount=self._cfg['bgp4mp']['rotate']['backupCount'],
                            delay=True)

        # Set the handler so we can remove it
        logger._handler = handler

        logger.addHandler(handler)

        return logger
